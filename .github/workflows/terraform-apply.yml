
# .github/workflows/terraform-apply.yml
name: "ðŸš€ Terraform Apply"

on:
  push:
    branches: [main]
    paths:
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stage
          - prod
      destroy:
        description: 'Destroy infrastructure instead of apply'
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: "1.5.7"
  AWS_REGION: "us-west-2"
  TF_IN_AUTOMATION: "true"

jobs:
  determine-environments:
    name: "ðŸŽ¯ Determine Deployment Strategy"
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.set-environments.outputs.environments }}
      action: ${{ steps.set-action.outputs.action }}
    steps:
      - name: ðŸŽ² Set Environments
        id: set-environments
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environments=[\"${{ github.event.inputs.environment }}\"]" >> $GITHUB_OUTPUT
          else
            # Auto-deploy only dev on main branch pushes
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
          fi

      - name: âš¡ Set Action
        id: set-action
        run: |
          if [ "${{ github.event.inputs.destroy }}" = "true" ]; then
            echo "action=destroy" >> $GITHUB_OUTPUT
          else
            echo "action=apply" >> $GITHUB_OUTPUT
          fi

  apply:
    name: "${{ needs.determine-environments.outputs.action == 'destroy' && 'ðŸ’¥ Destroy' || 'ðŸš€ Deploy' }} ${{ matrix.environment }}"
    runs-on: ubuntu-latest
    needs: determine-environments
    strategy:
      fail-fast: false
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}

    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.outputs.outputs.cluster_endpoint }}

    permissions:
      contents: read
      id-token: write

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_ROLE_ARN_{0}', upper(matrix.environment))] }}
          role-session-name: terraform-${{ needs.determine-environments.outputs.action }}-${{ matrix.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ“‹ Cache Terraform
        uses: actions/cache@v3
        with:
          path: |
            terraform/environments/${{ matrix.environment }}/.terraform
          key: terraform-${{ matrix.environment }}-${{ hashFiles('terraform/environments/${{ matrix.environment }}/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-${{ matrix.environment }}-

      - name: ðŸš€ Terraform Initialize
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform init -input=false
          echo "âœ… Terraform initialized for ${{ matrix.environment }}"

      - name: ðŸ“Š Terraform Plan
        if: needs.determine-environments.outputs.action == 'apply'
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform plan \
            -var-file="terraform.tfvars" \
            -out="terraform.plan" \
            -detailed-exitcode
          
          echo "âœ… Terraform plan completed"

      - name: âš ï¸ Production Confirmation
        if: matrix.environment == 'prod' && needs.determine-environments.outputs.action == 'apply'
        run: |
          echo "ðŸš¨ PRODUCTION DEPLOYMENT"
          echo "Environment: ${{ matrix.environment }}"
          echo "Action: ${{ needs.determine-environments.outputs.action }}"
          echo "This will modify production infrastructure!"

      - name: ðŸ’¥ Terraform Destroy
        if: needs.determine-environments.outputs.action == 'destroy'
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform plan -destroy \
            -var-file="terraform.tfvars" \
            -out="terraform.plan"
          
          terraform apply terraform.plan
          echo "ðŸ’¥ Infrastructure destroyed for ${{ matrix.environment }}"

      - name: ðŸš€ Terraform Apply
        if: needs.determine-environments.outputs.action == 'apply'
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform apply terraform.plan
          echo "âœ… Terraform apply completed for ${{ matrix.environment }}"

      - name: ðŸ“¤ Capture Outputs
        if: needs.determine-environments.outputs.action == 'apply'
        id: outputs
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          # Capture key outputs
          CLUSTER_ID=$(terraform output -raw cluster_id 2>/dev/null || echo "")
          CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint 2>/dev/null || echo "")
          VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "")
          
          echo "cluster_id=$CLUSTER_ID" >> $GITHUB_OUTPUT
          echo "cluster_endpoint=$CLUSTER_ENDPOINT" >> $GITHUB_OUTPUT
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          
          # Save all outputs
          terraform output -json > terraform-outputs.json

      - name: âš™ï¸ Configure kubectl
        if: needs.determine-environments.outputs.action == 'apply' && steps.outputs.outputs.cluster_id != ''
        run: |
          aws eks --region ${{ env.AWS_REGION }} update-kubeconfig \
            --name ${{ steps.outputs.outputs.cluster_id }}
          
          echo "âœ… kubectl configured for cluster: ${{ steps.outputs.outputs.cluster_id }}"

      - name: ðŸ” Verify ArgoCD Deployment
        if: needs.determine-environments.outputs.action == 'apply' && steps.outputs.outputs.cluster_id != ''
        timeout-minutes: 10
        run: |
          echo "ðŸ” Waiting for ArgoCD to be ready..."
          
          # Wait for ArgoCD namespace
          kubectl wait --for=condition=Ready namespace argocd --timeout=300s || echo "ArgoCD namespace not ready yet"
          
          # Wait for ArgoCD server
          kubectl wait --for=condition=Ready pod \
            -l app.kubernetes.io/name=argocd-server \
            -n argocd --timeout=300s || echo "ArgoCD server not ready yet"
          
          # Check ArgoCD applications
          kubectl get applications -n argocd || echo "No ArgoCD applications found yet"
          
          echo "âœ… ArgoCD verification completed"

      - name: ðŸ¥ Health Check
        if: needs.determine-environments.outputs.action == 'apply' && steps.outputs.outputs.cluster_id != ''
        run: |
          echo "ðŸ¥ Performing health checks..."
          
          # Cluster health
          kubectl get nodes
          kubectl get pods -A --field-selector=status.phase!=Running || true
          
          # ArgoCD health
          kubectl get pods -n argocd || echo "ArgoCD not deployed"
          
          # Monitoring health (if enabled)
          kubectl get pods -n monitoring || echo "Monitoring not deployed"
          
          echo "âœ… Health check completed"

      - name: ðŸ“¤ Upload Terraform Outputs
        if: needs.determine-environments.outputs.action == 'apply'
        uses: actions/upload-artifact@v3
        with:
          name: terraform-outputs-${{ matrix.environment }}
          path: terraform/environments/${{ matrix.environment }}/terraform-outputs.json
          retention-days: 30

      - name: ðŸ“Š Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Summary - ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action**: ${{ needs.determine-environments.outputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.determine-environments.outputs.action }}" = "apply" ]; then
            echo "**Cluster ID**: ${{ steps.outputs.outputs.cluster_id }}" >> $GITHUB_STEP_SUMMARY
            echo "**VPC ID**: ${{ steps.outputs.outputs.vpc_id }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ”— Quick Access" >> $GITHUB_STEP_SUMMARY
            echo "- Configure kubectl: \`aws eks --region ${{ env.AWS_REGION }} update-kubeconfig --name ${{ steps.outputs.outputs.cluster_id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- ArgoCD: \`kubectl port-forward svc/argocd-server -n argocd 8080:443\`" >> $GITHUB_STEP_SUMMARY
            echo "- Get ArgoCD password: \`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ’¬ Notify Slack
        if: always() && (matrix.environment == 'prod' || failure())
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#infrastructure'
          text: |
            ${{ needs.determine-environments.outputs.action == 'destroy' && 'ðŸ’¥ Infrastructure Destroyed' || 'ðŸš€ Infrastructure Deployed' }}
            Environment: ${{ matrix.environment }}
            Status: ${{ job.status }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
